<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* ThreeJS Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Video Preview (Small) */
        #video-container {
            position: absolute; bottom: 10px; right: 10px; z-index: 2;
            width: 120px; height: 90px; border: 1px solid #444; border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); opacity: 0.5;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* Start Button / Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; background: #00ffcc; border: none;
            border-radius: 50px; font-weight: bold; cursor: pointer; margin-top: 20px;
        }

        /* Debug Logger (To see errors on mobile) */
        #debug-log {
            position: absolute; top: 0; left: 0; z-index: 5;
            color: lime; font-size: 10px; background: rgba(0,0,0,0.5);
            padding: 5px; max-width: 200px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="debug-log">System Log:<br></div>

    <div id="overlay">
        <h1 style="color:white; margin:0;">Magic Particles</h1>
        <p style="color:#ccc;">Camera + Mic Required</p>
        <button id="start-btn">TAP TO START</button>
    </div>

    <div id="video-container">
        <video id="webcam" playsinline muted autoplay></video>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Logger Function ---
        const logBox = document.getElementById('debug-log');
        function log(msg) {
            logBox.innerHTML += msg + "<br>";
            console.log(msg);
        }
        window.onerror = function(msg, source, lineno) {
            log("ERROR: " + msg + " at line " + lineno);
        }

        log("System initiating...");

        // --- Config ---
        const PARTICLE_COUNT = 3000; // Safe for mobile
        const PARTICLE_SIZE = 0.25;

        // --- State ---
        let currentShape = 'sphere';
        let targetExpansion = 1.0;
        let handHue = 0.5;
        let voiceHue = 0.5;
        let volume = 0;
        let handDetected = false;

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.04);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        log("Renderer created.");

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;

        // --- Create Particles ---
        const geometry = new THREE.BufferGeometry();
        const currentPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 30;
            const y = (Math.random() - 0.5) * 30;
            const z = (Math.random() - 0.5) * 30;
            currentPositions[i*3] = x; currentPositions[i*3+1] = y; currentPositions[i*3+2] = z;
            targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create texture manually (fail-safe)
        const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
        const ctx = cvs.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0,'white'); grad.addColorStop(1,'transparent');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(cvs);
        texture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            map: texture
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        log("Particles added to scene.");

        // --- Shape Logic ---
        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 7;
                return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) };
            },
            heart: (i) => {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                return { x: x * 0.4, y: y * 0.4, z: (Math.random()-0.5)*4 };
            },
            saturn: (i) => {
                 if (i < PARTICLE_COUNT * 0.7) {
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 4;
                    return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) };
                }
                const angle = Math.random() * Math.PI * 2;
                const dist = 6 + Math.random() * 4;
                return { x: dist * Math.cos(angle), y: (Math.random()-0.5)*0.2, z: dist * Math.sin(angle) };
            }
        };

        function updateShape(name) {
            if(!Shapes[name]) return;
            log("Morphing to: " + name);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = Shapes[name](i);
                targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
            }
        }
        updateShape('sphere');

        // --- Animation Loop (Running Immediately) ---
        const colorObj = new THREE.Color();
        
        function animate() {
            requestAnimationFrame(animate);

            // Audio Influence
            if(isAudioActive) {
                updateAudioData();
            }
            
            // Logic: Mix Hand & Voice
            let finalHue = handDetected ? handHue : (voiceHue + timeOffset * 0.1);
            if(!handDetected && !isAudioActive) finalHue = (Date.now() * 0.0001) % 1; // Default rainbow

            colorObj.setHSL(finalHue, 1.0, 0.6);
            
            const exp = handDetected ? targetExpansion : (1 + volume * 2);
            const vib = volume * 0.5;

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;
                
                // Move towards target
                const tx = targetPositions[i3] * exp;
                const ty = targetPositions[i3+1] * exp;
                const tz = targetPositions[i3+2] * exp;

                pos[i3] += (tx - pos[i3]) * 0.05;
                pos[i3+1] += (ty - pos[i3+1]) * 0.05;
                pos[i3+2] += (tz - pos[i3+2]) * 0.05;

                // Vibration
                if(vib > 0.01) {
                    pos[i3] += (Math.random()-0.5)*vib;
                    pos[i3+1] += (Math.random()-0.5)*vib;
                    pos[i3+2] += (Math.random()-0.5)*vib;
                }

                // Color
                col[i3] = THREE.MathUtils.lerp(col[i3], colorObj.r, 0.1);
                col[i3+1] = THREE.MathUtils.lerp(col[i3+1], colorObj.g, 0.1);
                col[i3+2] = THREE.MathUtils.lerp(col[i3+2], colorObj.b, 0.1);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            scene.rotation.y += 0.002;
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Start animation immediately!
        animate();
        let timeOffset = 0;

        // --- Audio & Vision Setup (Triggered by Button) ---
        let audioContext, analyser, dataArray;
        let isAudioActive = false;
        let handLandmarker, webcam;

        document.getElementById('start-btn').addEventListener('click', async function() {
            document.getElementById('overlay').style.display = 'none';
            log("User clicked Start. Initializing...");

            // 1. Setup Audio
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const src = audioContext.createMediaStreamSource(stream);
                src.connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioActive = true;
                log("Audio Active.");
            } catch(e) {
                log("Audio Failed: " + e.message);
            }

            // 2. Setup Vision
            try {
                log("Loading AI Model...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                log("Model Loaded. Starting Camera...");
                
                const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcam = document.getElementById('webcam');
                webcam.srcObject = videoStream;
                webcam.addEventListener('loadeddata', predictWebcam);
                log("Camera Active.");
            } catch(e) {
                log("Camera/AI Failed: " + e.message);
            }
        });

        function updateAudioData() {
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for(let i=0; i<dataArray.length; i++) {
                const x = (dataArray[i] - 128) / 128;
                sum += x*x;
            }
            volume = Math.sqrt(sum / dataArray.length);
            // Simple frequency hack for color
            voiceHue = (volume * 5) % 1; 
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime && handLandmarker) {
                lastVideoTime = webcam.currentTime;
                const result = await handLandmarker.detectForVideo(webcam, performance.now());
                
                if (result.landmarks && result.landmarks.length > 0) {
                    handDetected = true;
                    const lm = result.landmarks[0];
                    
                    // Pinch
                    const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    targetExpansion = THREE.MathUtils.mapLinear(d, 0.02, 0.15, 0.5, 2.0);
                    handHue = lm[0].x;

                    // Fingers
                    let count = 0;
                    if (lm[8].y < lm[6].y) count++;
                    if (lm[12].y < lm[10].y) count++;
                    if (lm[16].y < lm[14].y) count++;
                    if (lm[20].y < lm[18].y) count++;
                    
                    if(count === 1) { if(currentShape !== 'sphere') { currentShape='sphere'; updateShape('sphere'); } }
                    if(count === 2) { if(currentShape !== 'heart') { currentShape='heart'; updateShape('heart'); } }
                    if(count >= 3) { if(currentShape !== 'saturn') { currentShape='saturn'; updateShape('saturn'); } }

                } else {
                    handDetected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
