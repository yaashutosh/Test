<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Morph AI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* Full Screen Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Video ko hide kar diya hai par background me chalega */
        #video-container {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none;
        }
        
        /* Minimal UI - Sirf bottom me chhota status */
        #ui-layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 10;
            color: rgba(255, 255, 255, 0.7); text-align: center; pointer-events: none;
            text-transform: uppercase; letter-spacing: 2px; font-size: 0.9rem;
        }
        
        #status-text {
            font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #555; font-size: 0.8rem; z-index: 20;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">Loading AI...</div>

    <div id="ui-layer">
        <div id="status-text">Waiting for Camera...</div>
        <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 5px;">Use 1-5 Fingers</div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Config ---
        const PARTICLE_COUNT = 15000; // Density badha di
        const PARTICLE_SIZE = 0.08;   // Size chhota kar diya clean look ke liye
        
        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;

        // --- Particles ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        for(let i=0; i<PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*50;
            positions[i*3+1] = (Math.random()-0.5)*50;
            positions[i*3+2] = (Math.random()-0.5)*50;
            targetPositions[i] = positions[i];
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE, vertexColors: true, blending: THREE.AdditiveBlending,
            depthWrite: false, transparent: true, opacity: 0.8
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Logic & Math ---
        let randomParams = { m: 5, n1: 1, n2: 1, n3: 1 };
        
        function superformula(phi, m, n1, n2, n3) {
            return Math.pow(Math.pow(Math.abs(Math.cos(m * phi / 4)), n2) + Math.pow(Math.abs(Math.sin(m * phi / 4)), n3), -1 / n1);
        }

        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                return { x: 8*Math.cos(theta)*Math.sin(phi), y: 8*Math.sin(theta)*Math.sin(phi), z: 8*Math.cos(phi) };
            },
            galaxy: (i) => {
                const angle = i * 0.1; const r = (i/PARTICLE_COUNT)*15;
                return { x: r*Math.cos(angle), y: (Math.random()-0.5)*r*0.2, z: r*Math.sin(angle) };
            },
            heart: (i) => {
                const phi = Math.random()*Math.PI*2; const theta = Math.random()*Math.PI;
                const x = 16*Math.pow(Math.sin(phi),3);
                const y = 13*Math.cos(phi)-5*Math.cos(2*phi)-2*Math.cos(3*phi)-Math.cos(4*phi);
                return { x: x*0.4, y: y*0.4, z: (Math.random()-0.5)*3 };
            },
            random: (i) => {
                const phi = (i/PARTICLE_COUNT)*Math.PI*2; 
                const theta = (i/PARTICLE_COUNT)*Math.PI*16;
                const r = 8 * superformula(phi, randomParams.m, randomParams.n1, randomParams.n2, randomParams.n3) * superformula(theta, randomParams.m, randomParams.n1, randomParams.n2, randomParams.n3);
                return { x: r*Math.cos(phi)*Math.sin(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(theta) };
            }
        };

        let currentShape = 'sphere';
        let targetExpansion = 1.0;
        let targetHue = 0.5;

        function updateTargets(shape) {
            const gen = Shapes[shape];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = gen(i);
                targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
            }
        }
        updateTargets('sphere');

        // --- AI Vision ---
        let handLandmarker;
        let lastCount = 0;
        
        async function startAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                document.getElementById('loading').style.display = 'none';
                startCam();
            } catch(e) {
                alert("AI Error: " + e);
            }
        }

        function startCam() {
            const webcam = document.getElementById('webcam');
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predict);
                document.getElementById('status-text').innerText = "Active. Show Hand.";
            }).catch(err => {
                alert("Camera Error! Please run on Localhost (Server), not double click file.");
            });
        }

        async function predict() {
            const webcam = document.getElementById('webcam');
            if(handLandmarker && webcam.currentTime > 0) {
                const result = await handLandmarker.detectForVideo(webcam, performance.now());
                if(result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    
                    // 1. Pinch for size
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    targetExpansion = pinch < 0.05 ? 3.0 : 1.0; // Pinch to explode

                    // 2. Position for color
                    targetHue = lm[9].x;

                    // 3. Count Fingers
                    let count = 0;
                    if(lm[8].y < lm[6].y) count++; if(lm[12].y < lm[10].y) count++;
                    if(lm[16].y < lm[14].y) count++; if(lm[20].y < lm[18].y) count++;
                    if(Math.abs(lm[4].x - lm[17].x) > 0.15) count++; // Thumb rough check

                    if(count !== lastCount) {
                        if(count === 1) { updateTargets('galaxy'); document.getElementById('status-text').innerText = "Galaxy"; }
                        if(count === 2) { updateTargets('heart'); document.getElementById('status-text').innerText = "Heart"; }
                        if(count === 3 || count === 4) { updateTargets('sphere'); document.getElementById('status-text').innerText = "Sphere"; }
                        if(count === 5) { 
                            randomParams = { m: Math.random()*10, n1: Math.random()*5, n2: Math.random()*5, n3: Math.random()*5 };
                            updateTargets('random'); 
                            document.getElementById('status-text').innerText = "Magic Design"; 
                        }
                        lastCount = count;
                    }
                } else {
                    targetExpansion = THREE.MathUtils.lerp(targetExpansion, 1.0, 0.1);
                }
            }
            requestAnimationFrame(predict);
        }

        // --- Loop ---
        const color = new THREE.Color();
        function animate() {
            const pos = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            color.setHSL(targetHue, 1, 0.5);

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;
                const tx = targetPositions[i3] * targetExpansion;
                const ty = targetPositions[i3+1] * targetExpansion;
                const tz = targetPositions[i3+2] * targetExpansion;
                
                pos[i3] += (tx - pos[i3]) * 0.08;
                pos[i3+1] += (ty - pos[i3+1]) * 0.08;
                pos[i3+2] += (tz - pos[i3+2]) * 0.08;

                cols[i3] = THREE.MathUtils.lerp(cols[i3], color.r, 0.05);
                cols[i3+1] = THREE.MathUtils.lerp(cols[i3+1], color.g, 0.05);
                cols[i3+2] = THREE.MathUtils.lerp(cols[i3+2], color.b, 0.05);
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        startAI();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
