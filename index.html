<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 240px; height: 180px; border: 2px solid #333; border-radius: 10px; overflow: hidden;
            transform: scaleX(-1); /* Mirror video for intuitive feel */
            opacity: 0.7;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: #00ffcc; pointer-events: none;
        }
        h1 { font-size: 1.2rem; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; }
        .instruction { font-size: 0.9rem; margin-bottom: 5px; opacity: 0.8; }
        .status { margin-top: 15px; font-weight: bold; color: #fff; }
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">Initializing Vision AI...</div>

    <div id="ui-layer">
        <h1>Particle Morph AI</h1>
        <div class="instruction">‚òùÔ∏è : Sphere</div>
        <div class="instruction">‚úåÔ∏è : Heart</div>
        <div class="instruction">ü§ü : Flower</div>
        <div class="instruction">üññ : Saturn</div>
        <div class="instruction">üñêÔ∏è : DNA Helix</div>
        <div class="instruction">---</div>
        <div class="instruction">ü§è Pinch: Expand/Contract</div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.15;
        const LERP_SPEED = 0.08; // How fast particles morph

        // --- State ---
        let currentShape = 'sphere';
        let targetExpansion = 1.0;
        let targetHue = 0.5;
        let handDetected = false;
        
        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- Particle System ---
        // We use BufferGeometry for performance
        const geometry = new THREE.BufferGeometry();
        const initialPositions = new Float32Array(PARTICLE_COUNT * 3);
        const currentPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize particles randomly first
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            
            initialPositions[i*3] = x;
            initialPositions[i*3+1] = y;
            initialPositions[i*3+2] = z;

            currentPositions[i*3] = x;
            currentPositions[i*3+1] = y;
            currentPositions[i*3+2] = z;

            targetPositions[i*3] = x;
            targetPositions[i*3+1] = y;
            targetPositions[i*3+2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Shader Material for glowing dots
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8,
            map: createCircleTexture()
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 8;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            },
            heart: (i) => {
                // Parametric heart
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                // Distribute points randomly to fill volume or surface
                // Using a modified surface equation for better visuals
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const r = 0.5; // scaling
                
                // Classic 2D heart extruded or rotated
                // Let's use a 3D Heart formula
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4; // Thickness
                
                return { x: x * 0.5, y: y * 0.5, z: z };
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v); 
                return {
                    x: r * Math.sin(v) * Math.cos(u),
                    y: r * Math.sin(v) * Math.sin(u),
                    z: r * Math.cos(v)
                };
            },
            saturn: (i) => {
                // 70% Planet, 30% Ring
                if (i < PARTICLE_COUNT * 0.7) {
                    // Planet Sphere
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 5;
                    return {
                        x: r * Math.cos(theta) * Math.sin(phi),
                        y: r * Math.sin(theta) * Math.sin(phi),
                        z: r * Math.cos(phi)
                    };
                } else {
                    // Ring
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 7 + Math.random() * 4;
                    return {
                        x: dist * Math.cos(angle),
                        y: (Math.random()-0.5) * 0.2, // Flat ring
                        z: dist * Math.sin(angle)
                    };
                }
            },
            dna: (i) => {
                const t = (i / PARTICLE_COUNT) * 10 * Math.PI;
                const radius = 3;
                const height = 20;
                const y = (i / PARTICLE_COUNT) * height - height/2;
                
                // Double helix
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                
                return {
                    x: radius * Math.cos(t + offset),
                    y: y,
                    z: radius * Math.sin(t + offset)
                };
            }
        };

        // --- Logic: Update Targets ---
        function updateShapeTargets(shapeName) {
            const generator = Shapes[shapeName];
            if(!generator) return;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const pos = generator(i);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
        }

        // Initialize first shape
        updateShapeTargets('sphere');

        // --- Helper: Texture ---
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- MediaPipe Setup ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').innerText = "Status: AI Ready. Enable Camera.";
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predictWebcam);
                document.getElementById('status-text').innerText = "Status: Tracking Active";
            });
        }

        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime) {
                lastVideoTime = webcam.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const result = await handLandmarker.detectForVideo(webcam, startTimeMs);
                    processHandData(result);
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        // --- Interaction Logic ---
        function processHandData(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                handDetected = true;
                const landmarks = result.landmarks[0];
                
                // 1. PINCH DETECTION (Thumb tip #4, Index tip #8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // Map distance (approx 0.02 to 0.2) to expansion (0.5 to 3.0)
                // Inverted logic: Wide pinch = Normal, Close pinch = Explode/Expand? 
                // Let's do: Wide Open = Big, Closed = Small
                targetExpansion = THREE.MathUtils.mapLinear(distance, 0.02, 0.2, 0.5, 2.5);
                targetExpansion = THREE.MathUtils.clamp(targetExpansion, 0.5, 3.0);

                // 2. POSITION COLOR (Wrist x position)
                // Landmarks x is 0-1. Map to hue.
                targetHue = landmarks[0].x;

                // 3. FINGER COUNTING (For shape switching)
                const count = countFingers(landmarks);
                const statusText = document.getElementById('status-text');
                
                let newShape = currentShape;
                if(count === 1) newShape = 'sphere';
                if(count === 2) newShape = 'heart';
                if(count === 3) newShape = 'flower';
                if(count === 4) newShape = 'saturn';
                if(count === 5) newShape = 'dna';

                if(newShape !== currentShape) {
                    currentShape = newShape;
                    updateShapeTargets(currentShape);
                    statusText.innerText = `Shape: ${currentShape.toUpperCase()} | Fingers: ${count}`;
                }

            } else {
                handDetected = false;
                // Slowly return to defaults if no hand
                targetExpansion = THREE.MathUtils.lerp(targetExpansion, 1.0, 0.05);
            }
        }

        function countFingers(landmarks) {
            // Simple logic: check if tip is higher than PIP joint (y is inverted in screen coords, so tip < pip means tip is higher)
            // Thumb is tricky (use x), but let's stick to simple Y check for fingers 2-5
            let count = 0;
            
            // Index (8 < 6)
            if (landmarks[8].y < landmarks[6].y) count++;
            // Middle (12 < 10)
            if (landmarks[12].y < landmarks[10].y) count++;
            // Ring (16 < 14)
            if (landmarks[16].y < landmarks[14].y) count++;
            // Pinky (20 < 18)
            if (landmarks[20].y < landmarks[18].y) count++;
            
            // Thumb (check X distance from pinky base to differentiate open/closed)
            // Or simple check: if thumb tip is to the left/right of IP joint depending on hand side.
            // Simplified: Just treat 4 fingers as 4, thumb usually makes 5.
            if (landmarks[4].x < landmarks[3].x && landmarks[5].x > landmarks[17].x) count++; // Right hand approx
            else if (landmarks[4].x > landmarks[3].x && landmarks[5].x < landmarks[17].x) count++; // Left hand approx

            // Clamp 1-5
            return Math.max(1, count); 
        }

        // --- Animation Loop ---
        const colorObj = new THREE.Color();
        const timeUniform = { value: 0 };

        function animate() {
            requestAnimationFrame(animate);

            // Update Particle Positions (Morphing)
            const positions = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            
            // Color Logic
            colorObj.setHSL(targetHue, 1.0, 0.6); // Dynamic Hue

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;

                // Interpolate position towards target
                // Apply expansion factor to the target, not current
                const tx = targetPositions[i3] * targetExpansion;
                const ty = targetPositions[i3+1] * targetExpansion;
                const tz = targetPositions[i3+2] * targetExpansion;

                positions[i3] += (tx - positions[i3]) * LERP_SPEED;
                positions[i3+1] += (ty - positions[i3+1]) * LERP_SPEED;
                positions[i3+2] += (tz - positions[i3+2]) * LERP_SPEED;

                // Add slight noise/vibration for "alive" feel
                positions[i3] += (Math.random()-0.5) * 0.05;
                positions[i3+1] += (Math.random()-0.5) * 0.05;
                positions[i3+2] += (Math.random()-0.5) * 0.05;

                // Update Colors (Gradient based on position + Hand Hue)
                // Mix set color with position-based variation
                cols[i3] = THREE.MathUtils.lerp(cols[i3], colorObj.r, 0.1);
                cols[i3+1] = THREE.MathUtils.lerp(cols[i3+1], colorObj.g, 0.1);
                cols[i3+2] = THREE.MathUtils.lerp(cols[i3+2], colorObj.b, 0.1);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            // Rotate the whole system slowly if not interacting
            if(!handDetected) {
                scene.rotation.y += 0.002;
            } else {
                // Follow hand slightly?
                scene.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        setupMediaPipe();
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
