<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gesture Controlled Atom Particles</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Courier New', monospace;
}
#canvas-container {
    position: absolute;
    inset: 0;
}
#video-container {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 240px;
    height: 180px;
    border: 2px solid #333;
    border-radius: 10px;
    overflow: hidden;
    opacity: 0.7;
    transform: scaleX(-1);
}
video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
#ui-layer {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #00ffcc;
    z-index: 3;
}
h1 {
    font-size: 1.2rem;
    margin-bottom: 10px;
}
.instruction {
    font-size: 0.85rem;
    opacity: 0.8;
}
.status {
    margin-top: 10px;
    color: #fff;
}
.loading {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 1.4rem;
    z-index: 10;
}
</style>
</head>

<body>

<div class="loading" id="loading">Initializing Vision AI‚Ä¶</div>

<div id="ui-layer">
    <h1>Particle Morph AI</h1>
    <div class="instruction">‚òùÔ∏è Sphere</div>
    <div class="instruction">‚úåÔ∏è Heart</div>
    <div class="instruction">ü§ü Flower</div>
    <div class="instruction">üññ Saturn</div>
    <div class="instruction">üñêÔ∏è Atom (Proton ‚Ä¢ Neutron ‚Ä¢ Electron)</div>
    <div class="instruction">ü§è Pinch = Scale</div>
    <div class="status" id="status-text"></div>
</div>

<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<div id="canvas-container"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

const PARTICLE_COUNT = 8000;
const LERP_SPEED = 0.08;

let currentShape = 'sphere';
let targetExpansion = 1;
let targetHue = 0.5;
let handDetected = false;

// THREE SETUP
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.getElementById('canvas-container').appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;

// PARTICLES
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const targets = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
    positions[i*3] = (Math.random()-0.5)*40;
    positions[i*3+1] = (Math.random()-0.5)*40;
    positions[i*3+2] = (Math.random()-0.5)*40;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
    size: 0.15,
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    map: createGlow()
});

const points = new THREE.Points(geometry, material);
scene.add(points);

// SHAPES
const Shapes = {
    sphere: i => {
        const phi = Math.acos(-1 + 2*i/PARTICLE_COUNT);
        const theta = Math.sqrt(PARTICLE_COUNT*Math.PI)*phi;
        return {
            x: 8*Math.cos(theta)*Math.sin(phi),
            y: 8*Math.sin(theta)*Math.sin(phi),
            z: 8*Math.cos(phi)
        };
    },

    heart: i => {
        const t = i/PARTICLE_COUNT * Math.PI*2;
        return {
            x: 8*Math.pow(Math.sin(t),3),
            y: 6*Math.cos(t)-2*Math.cos(2*t),
            z: (Math.random()-0.5)*4
        };
    },

    flower: i => {
        const a = Math.random()*Math.PI*2;
        const r = 5+3*Math.sin(6*a);
        return {
            x: r*Math.cos(a),
            y: r*Math.sin(a),
            z: (Math.random()-0.5)*6
        };
    },

    saturn: i => {
        if (i < PARTICLE_COUNT*0.7) {
            const phi = Math.acos(-1 + 2*i/(PARTICLE_COUNT*0.7));
            const t = Math.random()*Math.PI*2;
            return {
                x: 5*Math.sin(phi)*Math.cos(t),
                y: 5*Math.sin(phi)*Math.sin(t),
                z: 5*Math.cos(phi)
            };
        } else {
            const a = Math.random()*Math.PI*2;
            const d = 7 + Math.random()*4;
            return { x:d*Math.cos(a), y:0, z:d*Math.sin(a) };
        }
    },

    atom: i => {
        const nucleus = PARTICLE_COUNT*0.35;
        if (i < nucleus) {
            const r = Math.random()*1.5;
            const a = Math.random()*Math.PI*2;
            const p = Math.acos(2*Math.random()-1);
            return {
                x: r*Math.sin(p)*Math.cos(a),
                y: r*Math.sin(p)*Math.sin(a),
                z: r*Math.cos(p)
            };
        }
        const e = i-nucleus;
        const orbit = 4 + (e%3)*2;
        const a = e/PARTICLE_COUNT*Math.PI*8;
        return {
            x: orbit*Math.cos(a),
            y: orbit*Math.sin(a),
            z: Math.sin(a)*2
        };
    }
};

function updateShape(name){
    for(let i=0;i<PARTICLE_COUNT;i++){
        const p = Shapes[name](i);
        targets[i*3]=p.x;
        targets[i*3+1]=p.y;
        targets[i*3+2]=p.z;
    }
}
updateShape('sphere');

// MEDIAPIPE
let handLandmarker, lastTime=-1;
const webcam = document.getElementById('webcam');

async function initAI(){
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision,{
        baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
        runningMode:"VIDEO",
        numHands:1
    });
    document.getElementById('loading').style.display='none';
    navigator.mediaDevices.getUserMedia({video:true}).then(s=>{
        webcam.srcObject=s;
        webcam.onloadeddata=track;
    });
}
initAI();

async function track(){
    if(webcam.currentTime!==lastTime){
        lastTime=webcam.currentTime;
        const res = await handLandmarker.detectForVideo(webcam,performance.now());
        if(res.landmarks?.length){
            handDetected=true;
            const lm=res.landmarks[0];
            const d=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
            targetExpansion=THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(d,0.02,0.2,0.5,2.5),0.5,3);
            targetHue=lm[0].x;

            const fingers =
              (lm[8].y<lm[6].y)+(lm[12].y<lm[10].y)+(lm[16].y<lm[14].y)+(lm[20].y<lm[18].y);
            const map=['sphere','heart','flower','saturn','atom'];
            currentShape=map[Math.min(fingers,4)];
            updateShape(currentShape);
        } else handDetected=false;
    }
    requestAnimationFrame(track);
}

// ANIMATE
const color=new THREE.Color();
function animate(){
    requestAnimationFrame(animate);
    const pos=geometry.attributes.position.array;
    const col=geometry.attributes.color.array;

    for(let i=0;i<PARTICLE_COUNT;i++){
        const i3=i*3;
        pos[i3]+= (targets[i3]*targetExpansion-pos[i3])*LERP_SPEED;
        pos[i3+1]+= (targets[i3+1]*targetExpansion-pos[i3+1])*LERP_SPEED;
        pos[i3+2]+= (targets[i3+2]*targetExpansion-pos[i3+2])*LERP_SPEED;

        if(i<PARTICLE_COUNT*0.35) color.setHSL(0.02,1,0.6);
        else color.setHSL(0.55+targetHue*0.2,1,0.6);

        col[i3]=color.r; col[i3+1]=color.g; col[i3+2]=color.b;
    }

    geometry.attributes.position.needsUpdate=true;
    geometry.attributes.color.needsUpdate=true;
    scene.rotation.y+=handDetected?0.004:0.002;
    controls.update();
    renderer.render(scene,camera);
}
animate();

function createGlow(){
    const c=document.createElement('canvas');
    c.width=c.height=32;
    const x=c.getContext('2d');
    const g=x.createRadialGradient(16,16,0,16,16,16);
    g.addColorStop(0,'white');
    g.addColorStop(1,'transparent');
    x.fillStyle=g;
    x.fillRect(0,0,32,32);
    const t=new THREE.Texture(c);
    t.needsUpdate=true;
    return t;
}

addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
