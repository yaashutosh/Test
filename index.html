<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; pointer-events: none;
        }
        video { display: none; } /* Hide the raw webcam feed */
    </style>
</head>
<body>

    <div id="info">
        <h3>Hand Gesture Particles</h3>
        <p>üñê <b>Open Hand:</b> Move/Repel particles</p>
        <p>‚úä <b>Fist (Mutthi):</b> Implode/Attract to center</p>
        <p>üëÜ <b>Tap Fingers:</b> Cycle Shapes (Heart -> Saturn -> Ashutosh -> Flower)</p>
        <p id="status">Loading AI Model...</p>
    </div>

    <video id="input_video"></video>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 3000;
        const PARTICLE_SIZE = 0.15;
        const INTERACTION_RADIUS = 3;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const initialPositions = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize Random Positions
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            initialPositions[i] = positions[i];
            colors[i] = 1; // White init
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create a soft glow texture programmatically
        const getTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        };

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: getTexture(),
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE GENERATORS ---

        function setTargetShape(type) {
            const tempPositions = [];
            
            if (type === 'heart') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = Math.random() * Math.PI * 2;
                    // Heart Equation
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    const z = (Math.random() - 0.5) * 4; // Thickness
                    // Scale down
                    tempPositions.push(x * 0.5, y * 0.5, z); 
                }
                updateColors(1, 0.2, 0.4); // Red/Pink
            } 
            else if (type === 'saturn') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (i < PARTICLE_COUNT * 0.3) {
                        // Planet Sphere
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const r = 4;
                        tempPositions.push(
                            r * Math.sin(phi) * Math.cos(theta),
                            r * Math.sin(phi) * Math.sin(theta),
                            r * Math.cos(phi)
                        );
                    } else {
                        // Rings
                        const angle = Math.random() * Math.PI * 2;
                        const r = 6 + Math.random() * 4;
                        tempPositions.push(r * Math.cos(angle), (Math.random()-0.5), r * Math.sin(angle));
                    }
                }
                updateColors(0.8, 0.7, 0.3); // Gold
            }
            else if (type === 'flower') {
                 for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 8 * Math.cos(4 * theta); // Rose curve
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    const z = (Math.random() - 0.5) * 5;
                    tempPositions.push(x, y, z);
                }
                updateColors(0.5, 0.2, 0.9); // Purple
            }
            else if (type === 'ashutosh') {
                // Text generation requires sampling a 2D canvas
                const pts = getTextPoints("ASHUTOSH");
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const p = pts[i % pts.length];
                    tempPositions.push(p.x, p.y, (Math.random()-0.5)*2);
                }
                updateColors(0.2, 0.8, 1.0); // Cyan
            }
            else if (type === 'fist') {
                // Mutthi/Sphere shape
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 3;
                    tempPositions.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                updateColors(1.0, 0.5, 0.0); // Orange
            }

            // Apply to target array
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targets[i] = tempPositions[i] || 0;
            }
        }

        // Helper: Generate points from Text
        function getTextPoints(text) {
            const cvs = document.createElement('canvas');
            cvs.width = 200; cvs.height = 50;
            const ctx = cvs.getContext('2d');
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(text, cvs.width/2, 35);
            
            const data = ctx.getImageData(0,0, cvs.width, cvs.height).data;
            const points = [];
            for(let y=0; y<cvs.height; y+=2) {
                for(let x=0; x<cvs.width; x+=2) {
                    const alpha = data[(y*cvs.width + x)*4 + 3];
                    if(alpha > 128) {
                        // Map 2D to 3D space centered
                        points.push({
                            x: (x - cvs.width/2) * 0.25, 
                            y: -(y - cvs.height/2) * 0.25 
                        });
                    }
                }
            }
            return points.length > 0 ? points : [{x:0, y:0}];
        }

        function updateColors(r, g, b) {
            const colorAttr = geometry.attributes.color;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                colorAttr.setXYZ(i, r + (Math.random()-0.5)*0.2, g, b);
            }
            colorAttr.needsUpdate = true;
        }

        // --- HAND TRACKING LOGIC ---
        
        let handPos = new THREE.Vector3(999, 999, 0); // Default far away
        let isFist = false;
        let lastGestureTime = 0;
        let shapeIndex = 0;
        const shapes = ['ashutosh', 'heart', 'saturn', 'flower'];

        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            document.getElementById('status').innerText = "System Active";
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Hand Position in 3D Space
                // Map MediaPipe (0-1) to Three.js World Coords (approx -15 to 15)
                const x = (0.5 - landmarks[9].x) * 35; // Flip X for mirror effect
                const y = (0.5 - landmarks[9].y) * 25;
                handPos.set(x, y, 0);

                // 2. Detect Fist (Mutthi)
                // Compare Wrist (0) distance to Middle Finger Tip (12)
                const wrist = landmarks[0];
                const tip = landmarks[12];
                const distance = Math.sqrt(Math.pow(wrist.x - tip.x, 2) + Math.pow(wrist.y - tip.y, 2));
                
                isFist = distance < 0.2; // Threshold for fist

                // 3. Detect Gesture Change (Simple pinch or timeout based toggle)
                // If Index tip touches Thumb tip
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (pinchDist < 0.05 && Date.now() - lastGestureTime > 1500) {
                    shapeIndex = (shapeIndex + 1) % shapes.length;
                    setTargetShape(shapes[shapeIndex]);
                    lastGestureTime = Date.now();
                }

            } else {
                handPos.set(999, 999, 0); // Hand lost
            }
        }

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640,
            height: 480
        });
        cameraFeed.start();

        // --- ANIMATION LOOP ---

        // Init first shape
        setTargetShape('ashutosh');

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            const posAttr = geometry.attributes.position;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = posAttr.getX(i);
                const py = posAttr.getY(i);
                const pz = posAttr.getZ(i);

                // 1. Interpolate towards Target Shape
                let tx = targets[i * 3];
                let ty = targets[i * 3 + 1];
                let tz = targets[i * 3 + 2];

                // Add subtle idle noise
                tx += Math.sin(time + i) * 0.02;
                ty += Math.cos(time + i * 0.5) * 0.02;

                // 2. Hand Interaction
                const dist = Math.sqrt((px - handPos.x)**2 + (py - handPos.y)**2);
                
                if (isFist) {
                    // MUTTHI LOGIC: Attraction / Black Hole
                    // Overwrite target to be the hand position
                    const pullStrength = 5.0 * dt;
                    if(dist < 15) {
                        posAttr.setXYZ(i, 
                            px + (handPos.x - px) * pullStrength,
                            py + (handPos.y - py) * pullStrength,
                            pz + (0 - pz) * pullStrength
                        );
                        continue; // Skip standard interpolation
                    }
                } else if (dist < INTERACTION_RADIUS) {
                    // OPEN HAND: Repulsion
                    const angle = Math.atan2(py - handPos.y, px - handPos.x);
                    const force = (INTERACTION_RADIUS - dist) * 2;
                    tx += Math.cos(angle) * force;
                    ty += Math.sin(angle) * force;
                }

                // Standard Lerp Movement
                posAttr.setXYZ(i,
                    px + (tx - px) * 3 * dt,
                    py + (ty - py) * 3 * dt,
                    pz + (tz - pz) * 3 * dt
                );
            }

            posAttr.needsUpdate = true;
            particles.rotation.y += 0.001; // Slight global rotation
            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
