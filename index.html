<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission JVVN/RVUN Tracker</title>
    <!-- Tailwind CSS for styling (No installation needed) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: sans-serif; background-color: #f3f4f6; }
        .checkbox:checked + div { background-color: #10b981; border-color: #10b981; }
        .checkbox:checked + div svg { display: block; }
        .weak-active { color: #ef4444; background-color: #fee2e2; border: 1px solid #fca5a5; }
    </style>
</head>
<body class="pb-10">

    <!-- Header -->
    <div class="bg-blue-800 text-white p-4 sticky top-0 z-50 shadow-md">
        <div class="max-w-md mx-auto flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold">Mission RVUN/JVVN</h1>
                <p class="text-xs text-blue-200">7 Days Challenge (Auto-Save ON)</p>
            </div>
            <div class="text-right">
                <button onclick="resetData()" class="text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-white">Reset All</button>
            </div>
        </div>
        
        <!-- Day Navigation -->
        <div class="max-w-md mx-auto mt-4 flex gap-2 overflow-x-auto pb-2" id="dayTabs">
            <!-- Tabs will be injected here by JS -->
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-md mx-auto p-4" id="appContent">
        <!-- Content will be injected here by JS -->
    </div>

    <!-- JavaScript Logic -->
    <script>
        // --- DATA & CONFIG ---
        const startDate = 4;
        const totalDays = 7;
        
        const coreChapters = [
            { id: 13, name: "DC Generator (‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ß‡§æ‡§∞‡§æ ‡§ú‡§®‡§ø‡§§‡•ç‡§∞)" },
            { id: 14, name: "DC Motor (‡§¶‡§ø‡§∑‡•ç‡§ü ‡§ß‡§æ‡§∞‡§æ ‡§Æ‡•ã‡§ü‡§∞)" },
            { id: 15, name: "Alternator (‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡§æ‡§µ‡§∞‡•ç‡§§‡§ï)" },
            { id: 16, name: "1-Phase Motor (‡§è‡§ï‡§≤ ‡§ï‡§≤‡§æ ‡§Æ‡•ã‡§ü‡§∞)" },
            { id: 17, name: "3-Phase Induction Motor (‡§§‡•ç‡§∞‡§ø‡§ï‡§≤‡§æ ‡§™‡•ç‡§∞‡•á‡§∞‡§£ ‡§Æ‡•ã‡§ü‡§∞)" }
        ];

        const scheduleBatches = {
            0: [ // Day 4
                { id: 1, name: "Charge & Static Electricity" }, { id: 2, name: "Resistors (‡§™‡•ç‡§∞‡§§‡§ø‡§∞‡•ã‡§ß‡§ï)" },
                { id: 3, name: "D.C. Theory" }, { id: 25, name: "Safety Devices" }, { id: 4, name: "Capacitor & Inductor" }
            ],
            1: [ // Day 5
                { id: 5, name: "A.C. Theory & Polyphase" }, { id: 6, name: "Cells & Battery" },
                { id: 7, name: "Magnetism" }, { id: 8, name: "Earthing" }, { id: 9, name: "Underground Cables" }
            ],
            2: [ // Day 6
                { id: 10, name: "Cables & Joints" }, { id: 11, name: "Soldering" },
                { id: 12, name: "Transformer" }, { id: 18, name: "Winding" }, { id: 19, name: "Basic Electronics" }
            ],
            3: [ // Day 7
                { id: 20, name: "Diode & Rectifier" }, { id: 21, name: "Transistor & Amplifier" },
                { id: 22, name: "Measuring Instruments" }, { id: 23, name: "Generation" }, { id: 24, name: "Transmission" }
            ]
        };

        // --- STATE MANAGEMENT ---
        let currentDay = parseInt(localStorage.getItem('rvun_day')) || 0;
        let completedTasks = JSON.parse(localStorage.getItem('rvun_tasks')) || {};
        let weakTopics = JSON.parse(localStorage.getItem('rvun_weak')) || {};

        function saveData() {
            localStorage.setItem('rvun_day', currentDay);
            localStorage.setItem('rvun_tasks', JSON.stringify(completedTasks));
            localStorage.setItem('rvun_weak', JSON.stringify(weakTopics));
            render();
        }

        function toggleTask(key) {
            completedTasks[key] = !completedTasks[key];
            saveData();
        }

        function toggleWeak(id) {
            weakTopics[id] = !weakTopics[id];
            saveData();
        }

        function setDay(index) {
            currentDay = index;
            saveData();
        }

        function resetData() {
            if(confirm("‡§™‡•Ç‡§∞‡§æ ‡§°‡•á‡§ü‡§æ ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§π‡•ã ‡§ú‡§æ‡§Ø‡•á‡§ó‡§æ! ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∂‡•ç‡§Ø‡•ã‡§∞ ‡§π‡•à‡§Ç?")) {
                localStorage.clear();
                location.reload();
            }
        }

        // --- RENDER LOGIC ---
        function getTheoryChapters(dayIdx) {
            if (dayIdx < 4) return scheduleBatches[dayIdx];
            // Revision Logic
            const b0 = scheduleBatches[0]; const b1 = scheduleBatches[1];
            const b2 = scheduleBatches[2]; const b3 = scheduleBatches[3];
            
            if (dayIdx === 4) return [...b0, ...b1.slice(0, 2)];
            if (dayIdx === 5) return [...b1.slice(2), ...b2];
            if (dayIdx === 6) return [...b3, ...b0.slice(0, 2)];
            return [];
        }

        function render() {
            // Render Tabs
            const tabsContainer = document.getElementById('dayTabs');
            tabsContainer.innerHTML = '';
            for(let i=0; i<totalDays; i++) {
                const isActive = i === currentDay;
                const date = startDate + i;
                const btn = document.createElement('button');
                btn.className = `flex-shrink-0 px-4 py-2 rounded-lg text-sm font-bold transition-all ${isActive ? 'bg-yellow-400 text-blue-900 shadow-lg scale-105' : 'bg-blue-700 text-blue-200'}`;
                btn.innerHTML = `<div>Day ${i+1}</div><div class="text-lg">${date}</div>`;
                btn.onclick = () => setDay(i);
                tabsContainer.appendChild(btn);
            }

            // Render Content
            const app = document.getElementById('appContent');
            app.innerHTML = '';

            // Date Header
            const dateTitle = document.createElement('div');
            dateTitle.className = "text-center mb-6";
            const isRevision = currentDay >= 4;
            dateTitle.innerHTML = `
                <h2 class="text-gray-500 font-bold uppercase text-xs tracking-wider">Schedule for ${startDate + currentDay}th Month</h2>
                <div class="inline-block px-3 py-1 rounded-full text-xs font-bold mt-1 ${isRevision ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}">
                    ${isRevision ? '‚ö° Final Revision Phase' : 'üìö Syllabus Coverage Phase'}
                </div>
            `;
            app.appendChild(dateTitle);

            // Helper to create sections
            const createSection = (time, title, sub, color, type, items) => {
                const section = document.createElement('div');
                const borderClass = color === 'blue' ? 'border-blue-500 bg-blue-50' : (color === 'orange' ? 'border-orange-500 bg-orange-50' : 'border-green-500 bg-white');
                section.className = `mb-4 rounded-xl border-l-4 p-4 shadow-sm ${borderClass}`;
                
                let itemsHtml = '';
                
                if (items) {
                    items.forEach((item, idx) => {
                        const taskKey = `${currentDay}-${type}-${item.id}`;
                        const isDone = completedTasks[taskKey];
                        const isWeak = weakTopics[item.id];
                        
                        itemsHtml += `
                        <div class="flex items-center justify-between bg-white p-3 rounded-lg border border-gray-100 mb-2 shadow-sm">
                            <div class="flex items-center gap-3" onclick="toggleTask('${taskKey}')">
                                <div class="w-6 h-6 rounded-full border-2 border-gray-300 flex items-center justify-center ${isDone ? 'bg-green-500 border-green-500' : ''}">
                                    ${isDone ? '<span class="text-white text-sm">‚úì</span>' : ''}
                                </div>
                                <span class="text-sm font-medium ${isDone ? 'line-through text-gray-400' : 'text-gray-800'} cursor-pointer select-none">
                                    ${item.name}
                                </span>
                            </div>
                            <button onclick="toggleWeak(${item.id})" class="p-1 rounded ${isWeak ? 'weak-active' : 'text-gray-300 hover:text-gray-500'}">
                                ‚ö†Ô∏è
                            </button>
                        </div>`;
                    });
                } else {
                    const taskKey = `${currentDay}-${time}-main`;
                    const isDone = completedTasks[taskKey];
                    itemsHtml = `
                    <div class="flex items-center gap-3 bg-white p-3 rounded-lg shadow-sm" onclick="toggleTask('${taskKey}')">
                        <div class="w-6 h-6 rounded-full border-2 border-gray-300 flex items-center justify-center ${isDone ? 'bg-orange-500 border-orange-500' : ''}">
                             ${isDone ? '<span class="text-white text-sm">‚úì</span>' : ''}
                        </div>
                        <span class="font-bold text-gray-700 select-none">Mark Complete</span>
                    </div>`;
                }

                section.innerHTML = `
                    <div class="mb-3">
                        <div class="flex items-center gap-2 text-gray-700 font-bold text-sm">üïí ${time}</div>
                        <h3 class="text-lg font-bold text-gray-900">${title}</h3>
                        <p class="text-xs text-gray-600">${sub}</p>
                    </div>
                    <div>${itemsHtml}</div>
                `;
                app.appendChild(section);
            };

            // 1. Morning Slot
            createSection('04:00 - 07:00 AM', 'Daily Power Dose', '‡§Ø‡•á 5 ‡§ö‡•à‡§™‡•ç‡§ü‡§∞ ‡§∞‡•ã‡§ú ‡§™‡•ù‡§®‡•á ‡§π‡•à‡§Ç', 'blue', 'core', coreChapters);

            // 2. GK Slot
            createSection('09:00 - 02:00 PM', 'Rajasthan GK / Non-Tech', '‡§á‡§§‡§ø‡§π‡§æ‡§∏, ‡§ï‡§≤‡§æ, ‡§∏‡§Ç‡§∏‡•ç‡§ï‡•É‡§§‡§ø, ‡§≠‡•Ç‡§ó‡•ã‡§≤', 'orange', 'gk', null);

            // 3. Theory Slot
            const theoryItems = getTheoryChapters(currentDay);
            const theoryTitle = isRevision ? "Rapid Revision (Weak Topics)" : "Theory Deep Dive";
            const theorySub = isRevision ? "‡§≤‡§æ‡§≤ ‡§®‡§ø‡§∂‡§æ‡§® (‚ö†Ô∏è) ‡§µ‡§æ‡§≤‡•á ‡§ü‡•â‡§™‡§ø‡§ï‡•ç‡§∏ ‡§™‡§∞ ‡§´‡•ã‡§ï‡§∏ ‡§ï‡§∞‡•á‡§Ç" : "‡§Ü‡§ú ‡§ï‡•á 5 ‡§®‡§è ‡§ö‡•à‡§™‡•ç‡§ü‡§∞";
            createSection('02:30 - 07:00 PM', theoryTitle, theorySub, 'green', 'theory', theoryItems);

            // 4. Night Slot
            createSection('08:00 - 10:00 PM', 'GK Revision & Test', '‡§∞‡§ø‡§µ‡§ø‡§ú‡§® ‡§î‡§∞ ‡§™‡•ç‡§∞‡§∂‡•ç‡§®', 'orange', 'gk_night', null);
            
            // Revision Note
            if(isRevision) {
                const note = document.createElement('div');
                note.className = "mt-4 bg-red-50 text-red-700 p-3 rounded text-xs border border-red-200 text-center";
                note.innerText = "Note: ‡§Ö‡§¨ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§â‡§® ‡§ü‡•â‡§™‡§ø‡§ï‡•ç‡§∏ ‡§ï‡•ã ‡§™‡•ù‡•á‡§Ç ‡§ú‡§π‡§æ‡§Å ‡§Ü‡§™‡§®‡•á Warning (‚ö†Ô∏è) ‡§ï‡§æ ‡§®‡§ø‡§∂‡§æ‡§® ‡§≤‡§ó‡§æ‡§Ø‡§æ ‡§π‡•à‡•§";
                app.appendChild(note);
            }
        }

        // Initial Render
        render();

    </script>
</body>
</html>

// Shader Material for glowing dots
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8,
            map: createCircleTexture()
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 8;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            },
            heart: (i) => {
                // Parametric heart
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                // Distribute points randomly to fill volume or surface
                // Using a modified surface equation for better visuals
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const r = 0.5; // scaling
                
                // Classic 2D heart extruded or rotated
                // Let's use a 3D Heart formula
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4; // Thickness
                
                return { x: x * 0.5, y: y * 0.5, z: z };
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v); 
                return {
                    x: r * Math.sin(v) * Math.cos(u),
                    y: r * Math.sin(v) * Math.sin(u),
                    z: r * Math.cos(v)
                };
            },
            saturn: (i) => {
                // 70% Planet, 30% Ring
                if (i < PARTICLE_COUNT * 0.7) {
                    // Planet Sphere
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 5;
                    return {
                        x: r * Math.cos(theta) * Math.sin(phi),
                        y: r * Math.sin(theta) * Math.sin(phi),
                        z: r * Math.cos(phi)
                    };
                } else {
                    // Ring
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 7 + Math.random() * 4;
                    return {
                        x: dist * Math.cos(angle),
                        y: (Math.random()-0.5) * 0.2, // Flat ring
                        z: dist * Math.sin(angle)
                    };
                }
            },
            dna: (i) => {
                const t = (i / PARTICLE_COUNT) * 10 * Math.PI;
                const radius = 3;
                const height = 20;
                const y = (i / PARTICLE_COUNT) * height - height/2;
                
                // Double helix
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                
                return {
                    x: radius * Math.cos(t + offset),
                    y: y,
                    z: radius * Math.sin(t + offset)
                };
            }
        };

        // --- Logic: Update Targets ---
        function updateShapeTargets(shapeName) {
            const generator = Shapes[shapeName];
            if(!generator) return;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const pos = generator(i);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
        }

        // Initialize first shape
        updateShapeTargets('sphere');

        // --- Helper: Texture ---
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- MediaPipe Setup ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').innerText = "Status: AI Ready. Enable Camera.";
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predictWebcam);
                document.getElementById('status-text').innerText = "Status: Tracking Active";
            });
        }

        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime) {
                lastVideoTime = webcam.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const result = await handLandmarker.detectForVideo(webcam, startTimeMs);
                    processHandData(result);
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        // --- Interaction Logic ---
        function processHandData(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                handDetected = true;
                const landmarks = result.landmarks[0];
                
                // 1. PINCH DETECTION (Thumb tip #4, Index tip #8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // Map distance (approx 0.02 to 0.2) to expansion (0.5 to 3.0)
                // Inverted logic: Wide pinch = Normal, Close pinch = Explode/Expand? 
                // Let's do: Wide Open = Big, Closed = Small
                targetExpansion = THREE.MathUtils.mapLinear(distance, 0.02, 0.2, 0.5, 2.5);
                targetExpansion = THREE.MathUtils.clamp(targetExpansion, 0.5, 3.0);

                // 2. POSITION COLOR (Wrist x position)
                // Landmarks x is 0-1. Map to hue.
                targetHue = landmarks[0].x;

                // 3. FINGER COUNTING (For shape switching)
                const count = countFingers(landmarks);
                const statusText = document.getElementById('status-text');
                
                let newShape = currentShape;
                if(count === 1) newShape = 'sphere';
                if(count === 2) newShape = 'heart';
                if(count === 3) newShape = 'flower';
                if(count === 4) newShape = 'saturn';
                if(count === 5) newShape = 'dna';

                if(newShape !== currentShape) {
                    currentShape = newShape;
                    updateShapeTargets(currentShape);
                    statusText.innerText = `Shape: ${currentShape.toUpperCase()} | Fingers: ${count}`;
                }

            } else {
                handDetected = false;
                // Slowly return to defaults if no hand
                targetExpansion = THREE.MathUtils.lerp(targetExpansion, 1.0, 0.05);
            }
        }

        function countFingers(landmarks) {
            // Simple logic: check if tip is higher than PIP joint (y is inverted in screen coords, so tip < pip means tip is higher)
            // Thumb is tricky (use x), but let's stick to simple Y check for fingers 2-5
            let count = 0;
            
            // Index (8 < 6)
            if (landmarks[8].y < landmarks[6].y) count++;
            // Middle (12 < 10)
            if (landmarks[12].y < landmarks[10].y) count++;
            // Ring (16 < 14)
            if (landmarks[16].y < landmarks[14].y) count++;
            // Pinky (20 < 18)
            if (landmarks[20].y < landmarks[18].y) count++;
            
            // Thumb (check X distance from pinky base to differentiate open/closed)
            // Or simple check: if thumb tip is to the left/right of IP joint depending on hand side.
            // Simplified: Just treat 4 fingers as 4, thumb usually makes 5.
            if (landmarks[4].x < landmarks[3].x && landmarks[5].x > landmarks[17].x) count++; // Right hand approx
            else if (landmarks[4].x > landmarks[3].x && landmarks[5].x < landmarks[17].x) count++; // Left hand approx

            // Clamp 1-5
            return Math.max(1, count); 
        }

        // --- Animation Loop ---
        const colorObj = new THREE.Color();
        const timeUniform = { value: 0 };

        function animate() {
            requestAnimationFrame(animate);

            // Update Particle Positions (Morphing)
            const positions = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            
            // Color Logic
            colorObj.setHSL(targetHue, 1.0, 0.6); // Dynamic Hue

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;

                // Interpolate position towards target
                // Apply expansion factor to the target, not current
                const tx = targetPositions[i3] * targetExpansion;
                const ty = targetPositions[i3+1] * targetExpansion;
                const tz = targetPositions[i3+2] * targetExpansion;

                positions[i3] += (tx - positions[i3]) * LERP_SPEED;
                positions[i3+1] += (ty - positions[i3+1]) * LERP_SPEED;
                positions[i3+2] += (tz - positions[i3+2]) * LERP_SPEED;

                // Add slight noise/vibration for "alive" feel
                positions[i3] += (Math.random()-0.5) * 0.05;
                positions[i3+1] += (Math.random()-0.5) * 0.05;
                positions[i3+2] += (Math.random()-0.5) * 0.05;

                // Update Colors (Gradient based on position + Hand Hue)
                // Mix set color with position-based variation
                cols[i3] = THREE.MathUtils.lerp(cols[i3], colorObj.r, 0.1);
                cols[i3+1] = THREE.MathUtils.lerp(cols[i3+1], colorObj.g, 0.1);
                cols[i3+2] = THREE.MathUtils.lerp(cols[i3+2], colorObj.b, 0.1);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            // Rotate the whole system slowly if not interacting
            if(!handDetected) {
                scene.rotation.y += 0.002;
            } else {
                // Follow hand slightly?
                scene.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        setupMediaPipe();
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

