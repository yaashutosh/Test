<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Gesture Art AI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Video styling - Mirror effect active */
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 200px; height: 150px; 
            border: 1px solid rgba(0, 255, 204, 0.3); 
            border-radius: 12px; overflow: hidden;
            transform: scaleX(-1); 
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #video-container:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* HUD UI */
        #ui-layer {
            position: absolute; top: 30px; left: 30px; z-index: 3;
            color: #fff; pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        h1 { 
            font-size: 1.5rem; margin: 0 0 5px 0; 
            background: linear-gradient(90deg, #00ffcc, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 3px; 
        }
        .subtitle { font-size: 0.8rem; color: #aaa; margin-bottom: 20px; }
        
        .gesture-card {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00ffcc;
            margin-bottom: 10px;
            max-width: 250px;
        }
        .instruction { font-size: 0.9rem; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; }
        .key { color: #00ffcc; font-weight: bold; width: 20px; }
        
        .status-box {
            margin-top: 15px; padding: 10px;
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc; font-weight: bold;
            border-radius: 5px;
            display: inline-block;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-size: 2rem; z-index: 10; font-weight: lighter;
            text-shadow: 0 0 20px #00ffcc;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing Generative AI...</div>

    <div id="ui-layer">
        <h1>Morph Gen AI</h1>
        <div class="subtitle">Dynamic Hand Gesture Art</div>

        <div class="gesture-card">
            <div class="instruction"><span class="key">1</span> Noise Sphere</div>
            <div class="instruction"><span class="key">2</span> Abstract Heart</div>
            <div class="instruction"><span class="key">3</span> Procedural Flower</div>
            <div class="instruction"><span class="key">4</span> Galaxy Spiral</div>
            <div class="instruction"><span class="key">5</span> DNA Double Helix</div>
        </div>

        <div class="gesture-card" style="border-left-color: #ff00cc;">
            <div class="instruction">ü§è Pinch: Resize & Explode</div>
            <div class="instruction">üëã Move Hand: Color Shift</div>
        </div>

        <div class="status-box" id="status-text">Waiting for Camera...</div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 12000; // Increased for better density
        const PARTICLE_SIZE = 0.12;
        const LERP_SPEED = 0.06;

        // --- State Variables ---
        let currentGesture = 0; // 0=None, 1-5=Shapes
        let shapeParams = {};   // Holds random seeds for the current shape
        let targetExpansion = 1.0;
        let handHue = 0.0;
        let handDetected = false;
        
        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02); // Matches background

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const randomOffsets = new Float32Array(PARTICLE_COUNT); // For twinkling

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5) * 50;
            positions[i*3+1] = (Math.random()-0.5) * 50;
            positions[i*3+2] = (Math.random()-0.5) * 50;
            
            targetPositions[i*3] = positions[i*3];
            targetPositions[i*3+1] = positions[i*3+1];
            targetPositions[i*3+2] = positions[i*3+2];

            randomOffsets[i] = Math.random() * Math.PI * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Custom Shader Material for better visual control
        const texture = createGlowTexture();
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            map: texture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Generative Shape Logic ---
        // This function creates random parameters whenever a new shape is requested
        function generateRandomParams(type) {
            const r = Math.random;
            return {
                noiseStrength: r() * 2 + 0.5,
                radius: 6 + r() * 4,
                petals: Math.floor(r() * 6) + 3, // 3 to 9 petals
                petalDepth: r() * 2 + 0.5,
                spiralArms: Math.floor(r() * 5) + 2,
                twist: r() * 4,
                heartFatness: 0.5 + r() * 1.0,
                randomSeed: r() * 100
            };
        }

        const Generators = {
            1: (i, p) => { // Noisy Sphere / Planet
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                // Add Perlin-ish noise using sin/cos combinations
                const noise = Math.sin(phi * 5 + p.randomSeed) * Math.cos(theta * 5) * p.noiseStrength;
                const r = p.radius + noise;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            },
            2: (i, p) => { // Abstract Heart
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                // Randomize distribution
                const spread = Math.random() * 2 * Math.PI;
                // 3D Heart formula with adjustable width (p.heartFatness)
                const x = 16 * Math.pow(Math.sin(spread), 3) * p.heartFatness;
                const y = 13 * Math.cos(spread) - 5 * Math.cos(2*spread) - 2 * Math.cos(3*spread) - Math.cos(4*spread);
                // Extrude Z based on index with some twist
                const z = (Math.random() - 0.5) * 6;
                return { x: x * 0.4, y: y * 0.4, z: z };
            },
            3: (i, p) => { // Procedural Flower
                // p.petals determines 'k' in rose curve
                const k = p.petals; 
                const theta = Math.random() * Math.PI * 2 * k; 
                const phi = Math.random() * Math.PI;
                // Rose curve equation: r = cos(k * theta)
                const rBase = 6 + 3 * Math.cos(k * theta);
                const r = rBase * Math.sin(phi);
                return {
                    x: r * Math.cos(theta),
                    y: r * Math.sin(theta),
                    z: rBase * Math.cos(phi) * p.petalDepth // Depth variation
                };
            },
            4: (i, p) => { // Galaxy Spiral
                const armIndex = i % p.spiralArms;
                const radius = Math.random() * 10;
                const spin = radius * 0.5 + (armIndex * (Math.PI * 2 / p.spiralArms));
                // Add vertical chaos for volume
                const h = (Math.random() - 0.5) * (12 - radius); 
                return {
                    x: Math.cos(spin + p.twist) * radius,
                    y: h * 0.5,
                    z: Math.sin(spin + p.twist) * radius
                };
            },
            5: (i, p) => { // DNA / Helix
                const t = (i / PARTICLE_COUNT) * 12 * Math.PI;
                const radius = 3 + Math.sin(t * 0.1) * 1; // Varying width
                const height = 25;
                const y = (i / PARTICLE_COUNT) * height - height/2;
                const strand = (i % 2 === 0) ? 0 : Math.PI;
                return {
                    x: radius * Math.cos(t + strand + p.twist),
                    y: y,
                    z: radius * Math.sin(t + strand + p.twist)
                };
            }
        };

        function updateTargets(gestureId) {
            if (!Generators[gestureId]) return;
            
            // Generate NEW random parameters specifically for this instance
            shapeParams = generateRandomParams(gestureId);
            
            const generator = Generators[gestureId];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const pos = generator(i, shapeParams);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
        }

        // Initialize with Sphere
        updateTargets(1);

        // --- Utils ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const t = new THREE.Texture(canvas);
            t.needsUpdate = true;
            return t;
        }

        // --- Vision AI ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        async function setupVision() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').innerText = "AI Ready. Starting Camera...";
            startCam();
        }

        function startCam() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predict);
                document.getElementById('status-text').innerText = "System Active | Show Hand";
                document.getElementById('status-text').style.background = "rgba(0, 255, 0, 0.2)";
            });
        }

        async function predict() {
            if (lastVideoTime !== webcam.currentTime && handLandmarker) {
                lastVideoTime = webcam.currentTime;
                const result = await handLandmarker.detectForVideo(webcam, performance.now());
                processResult(result);
            }
            requestAnimationFrame(predict);
        }

        function processResult(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                handDetected = true;
                const marks = result.landmarks[0];

                // 1. Color Logic (X Position)
                handHue = marks[9].x; // Middle finger knuckle normalized X

                // 2. Pinch Logic (Scale)
                const d = Math.hypot(marks[4].x - marks[8].x, marks[4].y - marks[8].y);
                targetExpansion = THREE.MathUtils.mapLinear(d, 0.02, 0.15, 0.5, 2.0);
                targetExpansion = THREE.MathUtils.clamp(targetExpansion, 0.5, 3.0);

                // 3. Gesture Counting
                const fingers = countFingers(marks);
                
                // CRITICAL: Only update shape if gesture changed!
                // This ensures "New Design" is generated once per gesture switch
                if (fingers !== currentGesture && fingers > 0) {
                    currentGesture = fingers;
                    
                    // Update UI
                    const shapesNames = ["None", "Noisy Sphere", "Abstract Heart", "Procedural Flower", "Galaxy Spiral", "DNA Helix"];
                    document.getElementById('status-text').innerText = `Active: ${shapesNames[fingers] || 'Unknown'}`;
                    
                    // Trigger Generative Math
                    updateTargets(currentGesture);
                }

            } else {
                handDetected = false;
                // Gently reset expansion
                targetExpansion = THREE.MathUtils.lerp(targetExpansion, 1.0, 0.05);
            }
        }

        function countFingers(lm) {
            let c = 0;
            // Tips higher than PIP joints (y is inverted)
            if (lm[8].y < lm[6].y) c++; // Index
            if (lm[12].y < lm[10].y) c++; // Middle
            if (lm[16].y < lm[14].y) c++; // Ring
            if (lm[20].y < lm[18].y) c++; // Pinky
            
            // Thumb: Check x distance relative to wrist to see if extended
            const thumbExtended = Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x); 
            // Simple approach: if thumb is far from index base
            if(thumbExtended) c++;

            return Math.max(0, Math.min(5, c));
        }

        // --- Loop ---
        const clock = new THREE.Clock();
        const tempColor = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Dynamic Color Object
            tempColor.setHSL(handDetected ? handHue : (time * 0.1) % 1, 0.8, 0.6);

            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;

                // 1. Morphing Physics
                const tx = targetPositions[i3] * targetExpansion;
                const ty = targetPositions[i3+1] * targetExpansion;
                const tz = targetPositions[i3+2] * targetExpansion;

                posAttr.array[i3] += (tx - posAttr.array[i3]) * LERP_SPEED;
                posAttr.array[i3+1] += (ty - posAttr.array[i3+1]) * LERP_SPEED;
                posAttr.array[i3+2] += (tz - posAttr.array[i3+2]) * LERP_SPEED;

                // 2. Alive Motion (Noise)
                const noiseSpeed = 0.5;
                const noiseAmp = 0.03;
                posAttr.array[i3] += Math.sin(time * noiseSpeed + randomOffsets[i]) * noiseAmp;
                posAttr.array[i3+1] += Math.cos(time * noiseSpeed + randomOffsets[i]) * noiseAmp;

                // 3. Coloring & Twinkling
                // Twinkle logic: sin wave based on time + random offset
                const twinkle = Math.sin(time * 3 + randomOffsets[i]) * 0.5 + 0.5; 
                
                // Mix base color with white based on twinkle
                colAttr.array[i3] = THREE.MathUtils.lerp(tempColor.r, 1.0, twinkle * 0.3);
                colAttr.array[i3+1] = THREE.MathUtils.lerp(tempColor.g, 1.0, twinkle * 0.3);
                colAttr.array[i3+2] = THREE.MathUtils.lerp(tempColor.b, 1.0, twinkle * 0.3);
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;

            // Rotate Scene Logic
            if(handDetected) {
                // Slight tilt based on hand position
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, (handHue - 0.5), 0.05);
                scene.rotation.y += 0.01; // Faster spin when active
            } else {
                scene.rotation.y += 0.002; // Idle spin
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, 0, 0.05);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        setupVision();
        animate();

    </script>
</body>
</html>
