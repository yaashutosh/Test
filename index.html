<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            transform: scaleX(-1); /* Mirror the webcam feed */
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            pointer-events: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }
        h1 { font-size: 1.2rem; margin: 0 0 5px 0; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 0.9rem; margin: 0; color: #aaa; }
        .highlight { color: #00ffcc; font-weight: bold; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="instructions">
        <h1>Particle Morpher</h1>
        <p>üñê Move hand to control position</p>
        <p>üëå <span class="highlight">PINCH</span> (Index + Thumb) to switch shapes</p>
    </div>

    <div id="video-container">
        <video id="webcam" playsinline></video>
    </div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.15;
    const SMOOTHING = 0.08; // Lerp factor for movement

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
        colors[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Custom shader material for better performance and glow look
    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- SHAPE GENERATORS (MATH) ---
    const Shapes = {
        SPHERE: (i) => {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 10 + Math.random() * 2;
            return [
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            ];
        },
        HEART: (i) => {
            // Heart formula
            let x = (Math.random() - 0.5) * 25;
            let z = (Math.random() - 0.5) * 25;
            // Filter to keep points inside rough heart volume or just surface
            // Using a parametric surface approach for cleaner look:
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            
            // 3D Heart equation roughly
            const t = theta; 
            x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            z = (Math.random() - 0.5) * 5; // Thickness
            
            // Rotate to face camera
            return [x * 0.8, y * 0.8, z]; 
        },
        SATURN: (i) => {
            // 70% Ring, 30% Planet
            if (Math.random() > 0.3) {
                // Ring
                const angle = Math.random() * Math.PI * 2;
                const r = 15 + Math.random() * 8;
                return [r * Math.cos(angle), (Math.random()-0.5), r * Math.sin(angle)];
            } else {
                // Planet
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 6;
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            }
        },
        FLOWER: (i) => {
            const u = Math.random() * Math.PI * 8; // Loops
            const v = (Math.random() - 0.5) * 2;
            const r = 10 * (1 + 0.5 * Math.sin(2.5 * u)); // Flower petal radius modulation
            
            const x = r * Math.cos(u);
            const y = r * Math.sin(u);
            const z = v * 5;
            return [x, y, z];
        }
    };

    let currentShapeIndex = 0;
    const shapeKeys = Object.keys(Shapes);

    function morphToShape(shapeName) {
        const generator = Shapes[shapeName];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const [x, y, z] = generator(i);
            targetPositions[i * 3] = x;
            targetPositions[i * 3 + 1] = y;
            targetPositions[i * 3 + 2] = z;
        }
    }

    // Initial Shape
    morphToShape('SPHERE');

    // --- INTERACTION STATE ---
    let handPos = { x: 0, y: 0, z: 0 };
    let isPinching = false;
    let lastPinchTime = 0;
    let handVisible = false;

    // --- MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('webcam');
    
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handVisible = true;
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Track Index Finger Tip (Landmark 8) for position
            // Remap from [0,1] to 3D world coordinates roughly [-20, 20]
            const x = (0.5 - landmarks[8].x) * 60; // Inverted X for mirror effect
            const y = (0.5 - landmarks[8].y) * 40; // Inverted Y because canvas Y is down
            
            // Smoothly update hand position
            handPos.x += (x - handPos.x) * 0.2;
            handPos.y += (y - handPos.y) * 0.2;

            // 2. Detect Pinch (Thumb Tip 4 vs Index Tip 8)
            const dx = landmarks[8].x - landmarks[4].x;
            const dy = landmarks[8].y - landmarks[4].y;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if (distance < 0.05) { // Threshold for pinch
                if (!isPinching && Date.now() - lastPinchTime > 1000) {
                    // Trigger Shape Switch
                    triggerShapeSwitch();
                    lastPinchTime = Date.now();
                }
                isPinching = true;
            } else {
                isPinching = false;
            }

        } else {
            handVisible = false;
            // Slowly center if no hand
            handPos.x *= 0.95;
            handPos.y *= 0.95;
        }
    }

    function triggerShapeSwitch() {
        currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
        const newShape = shapeKeys[currentShapeIndex];
        console.log("Switching to", newShape);
        morphToShape(newShape);
        
        // Flash effect color change
        const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
        particles.material.color = color;
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttribute = geometry.attributes.position;
        const array = positionsAttribute.array;
        
        // Dynamic interaction logic
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            
            // 1. Morphing: Move current pos toward target pos
            // Using a spring-like ease
            array[idx] += (targetPositions[idx] - array[idx]) * 0.05;
            array[idx + 1] += (targetPositions[idx + 1] - array[idx + 1]) * 0.05;
            array[idx + 2] += (targetPositions[idx + 2] - array[idx + 2]) * 0.05;

            // 2. Hand Attraction / Distortion
            if (handVisible) {
                const dx = array[idx] - handPos.x;
                const dy = array[idx + 1] - handPos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // If particles are close to hand, push them out slightly (interactive field)
                // or pull them (magnet). Let's do a cool "turbulence" effect.
                if (dist < 10) {
                    const force = (10 - dist) * 0.5; // Strength
                    // Add noise based on time
                    array[idx] += (Math.random() - 0.5) * force;
                    array[idx+1] += (Math.random() - 0.5) * force;
                }
            }
            
            // 3. Constant rotation of the whole system based on hand X
            // We rotate the container or calculate here. Let's just rotate the container object
        }
        
        // Rotate the whole particle cloud
        particles.rotation.y = time * 0.1 + (handPos.x * 0.01);
        particles.rotation.x = (handPos.y * 0.01);

        // Dynamic Color shifting based on pinch or time
        if (isPinching) {
             particles.material.size = PARTICLE_SIZE * 1.5; // Grow when pinching
        } else {
             particles.material.size = THREE.MathUtils.lerp(particles.material.size, PARTICLE_SIZE, 0.1);
        }

        positionsAttribute.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
