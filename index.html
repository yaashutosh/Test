<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 240px; height: 180px; border: 2px solid #333; border-radius: 10px; overflow: hidden;
            transform: scaleX(-1); /* Mirror video for intuitive feel */
            opacity: 0.7;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: #00ffcc; pointer-events: none;
        }
        h1 { font-size: 1.2rem; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; }
        .instruction { font-size: 0.9rem; margin-bottom: 5px; opacity: 0.8; }
        .instruction.special { color: #ff3366; font-weight: bold; }
        .status { margin-top: 15px; font-weight: bold; color: #fff; }
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">Initializing Vision AI...</div>

    <div id="ui-layer">
        <h1>Particle Morph AI</h1>
        <div class="instruction">‚òùÔ∏è 1 Finger: Sphere</div>
        <div class="instruction">‚úåÔ∏è 2 Fingers: Heart</div>
        <div class="instruction">ü§ü 3 Fingers: Flower</div>
        <div class="instruction">üññ 4 Fingers: Saturn</div>
        <div class="instruction">üñêÔ∏è 5 Fingers: DNA Helix</div>
        <div class="instruction special">üñï Middle Finger: Letter Y</div>
        <div class="instruction">---</div>
        <div class="instruction">ü§è Pinch: Expand/Contract</div>
        <div class="instruction">‚ÜîÔ∏è Move Hand L/R: Change Color</div>
        <div class="status" id="status-text">Status: Waiting for camera...</div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.15;
        const LERP_SPEED = 0.08; // How fast particles morph

        // --- State ---
        let currentShape = 'sphere';
        let targetExpansion = 1.0;
        let targetHue = 0.5;
        let handDetected = false;
        
        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const initialPositions = new Float32Array(PARTICLE_COUNT * 3);
        const currentPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize particles randomly first
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            
            initialPositions[i*3] = x;
            initialPositions[i*3+1] = y;
            initialPositions[i*3+2] = z;

            currentPositions[i*3] = x;
            currentPositions[i*3+1] = y;
            currentPositions[i*3+2] = z;

            targetPositions[i*3] = x;
            targetPositions[i*3+1] = y;
            targetPositions[i*3+2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Shader Material for glowing dots
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8,
            map: createCircleTexture()
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 8;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            },
            heart: (i) => {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4; 
                return { x: x * 0.5, y: y * 0.5, z: z };
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v); 
                return {
                    x: r * Math.sin(v) * Math.cos(u),
                    y: r * Math.sin(v) * Math.sin(u),
                    z: r * Math.cos(v)
                };
            },
            saturn: (i) => {
                if (i < PARTICLE_COUNT * 0.7) {
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 5;
                    return {
                        x: r * Math.cos(theta) * Math.sin(phi),
                        y: r * Math.sin(theta) * Math.sin(phi),
                        z: r * Math.cos(phi)
                    };
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 7 + Math.random() * 4;
                    return {
                        x: dist * Math.cos(angle),
                        y: (Math.random()-0.5) * 0.2,
                        z: dist * Math.sin(angle)
                    };
                }
            },
            dna: (i) => {
                const t = (i / PARTICLE_COUNT) * 10 * Math.PI;
                const radius = 3;
                const height = 20;
                const y = (i / PARTICLE_COUNT) * height - height/2;
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                return {
                    x: radius * Math.cos(t + offset),
                    y: y,
                    z: radius * Math.sin(t + offset)
                };
            },
            // --- NEW SHAPE: LETTER A ---
            letterA: (i) => {
                // Distribute particles: 40% Left Leg, 40% Right Leg, 20% Bar
                const section = i / PARTICLE_COUNT;
                let x, y, z;
                
                if(section < 0.4) {
                    // Left leg: (-5, -8) to (0, 8)
                    const t = section / 0.4;
                    x = THREE.MathUtils.lerp(-5, 0, t);
                    y = THREE.MathUtils.lerp(-8, 8, t);
                    z = (Math.random() - 0.5) * 2; // Thickness
                } else if (section < 0.8) {
                    // Right leg: (0, 8) to (5, -8)
                    const t = (section - 0.4) / 0.4;
                    x = THREE.MathUtils.lerp(0, 5, t);
                    y = THREE.MathUtils.lerp(8, -8, t);
                    z = (Math.random() - 0.5) * 2;
                } else {
                    // Crossbar: (-2.5, -2) to (2.5, -2)
                    const t = (section - 0.8) / 0.2;
                    x = THREE.MathUtils.lerp(-2.5, 2.5, t);
                    y = -1 + (Math.random()-0.5); // Add jitter to bar
                    z = (Math.random() - 0.5) * 2;
                }
                return { x: x * 1.5, y: y * 1.5, z };
            },
            // --- NEW SHAPE: LETTER Y ---
            letterY: (i) => {
                // 33% Left Arm, 33% Right Arm, 33% Stem
                const section = i / PARTICLE_COUNT;
                let x, y, z;

                if (section < 0.33) {
                    // Left Arm: (-5, 8) to (0, 0)
                    const t = section / 0.33;
                    x = THREE.MathUtils.lerp(-5, 0, t);
                    y = THREE.MathUtils.lerp(8, 0, t);
                    z = (Math.random() - 0.5) * 2;
                } else if (section < 0.66) {
                    // Right Arm: (5, 8) to (0, 0)
                    const t = (section - 0.33) / 0.33;
                    x = THREE.MathUtils.lerp(5, 0, t);
                    y = THREE.MathUtils.lerp(8, 0, t);
                    z = (Math.random() - 0.5) * 2;
                } else {
                    // Stem: (0, 0) to (0, -8)
                    const t = (section - 0.66) / 0.34;
                    x = (Math.random() - 0.5) * 1.5; // Thicker stem
                    y = THREE.MathUtils.lerp(0, -8, t);
                    z = (Math.random() - 0.5) * 2;
                }
                return { x: x * 1.5, y: y * 1.5, z };
            }
        };

        // --- Logic: Update Targets ---
        function updateShapeTargets(shapeName) {
            const generator = Shapes[shapeName];
            if(!generator) return;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const pos = generator(i);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
        }

        updateShapeTargets('sphere');

        // --- Helper: Texture ---
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- MediaPipe Setup ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').innerText = "Status: AI Ready. Enable Camera.";
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predictWebcam);
                document.getElementById('status-text').innerText = "Status: Tracking Active";
            });
        }

        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime) {
                lastVideoTime = webcam.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const result = await handLandmarker.detectForVideo(webcam, startTimeMs);
                    processHandData(result);
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        // --- Interaction Logic ---
        function processHandData(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                handDetected = true;
                const landmarks = result.landmarks[0];
                
                // 1. PINCH DETECTION
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                targetExpansion = THREE.MathUtils.mapLinear(distance, 0.02, 0.2, 0.5, 2.5);
                targetExpansion = THREE.MathUtils.clamp(targetExpansion, 0.5, 3.0);

                // 2. POSITION COLOR
                targetHue = landmarks[0].x;

                // 3. SHAPE DETECTION LOGIC
                const statusText = document.getElementById('status-text');
                let newShape = currentShape;

                // SPECIAL: Check for Middle Finger (Shape Y)
                if (isMiddleFingerGesture(landmarks)) {
                    newShape = 'letterY'; // You can change this to 'letterA' if preferred
                } 
                else {
                    // Standard counting
                    const count = countFingers(landmarks);
                    if(count === 1) newShape = 'sphere';
                    if(count === 2) newShape = 'heart';
                    if(count === 3) newShape = 'flower';
                    if(count === 4) newShape = 'saturn';
                    if(count === 5) newShape = 'dna';
                }

                if(newShape !== currentShape) {
                    currentShape = newShape;
                    updateShapeTargets(currentShape);
                    
                    if(newShape === 'letterY') {
                         statusText.innerText = `Status: MIDDLE FINGER DETECTED! (Shape Y)`;
                         statusText.style.color = '#ff3366';
                    } else {
                         statusText.innerText = `Shape: ${currentShape.toUpperCase()}`;
                         statusText.style.color = '#fff';
                    }
                }

            } else {
                handDetected = false;
                targetExpansion = THREE.MathUtils.lerp(targetExpansion, 1.0, 0.05);
            }
        }

        // Specific detection for Middle Finger üñï
        function isMiddleFingerGesture(landmarks) {
            // Index (8) Tip below PIP (6) -> Curled
            const indexCurled = landmarks[8].y > landmarks[6].y;
            // Middle (12) Tip above PIP (10) -> Extended (Y is inverted)
            const middleExtended = landmarks[12].y < landmarks[10].y;
            // Ring (16) Tip below PIP (14) -> Curled
            const ringCurled = landmarks[16].y > landmarks[14].y;
            // Pinky (20) Tip below PIP (18) -> Curled
            const pinkyCurled = landmarks[20].y > landmarks[18].y;

            return indexCurled && middleExtended && ringCurled && pinkyCurled;
        }

        function countFingers(landmarks) {
            let count = 0;
            if (landmarks[8].y < landmarks[6].y) count++;
            if (landmarks[12].y < landmarks[10].y) count++;
            if (landmarks[16].y < landmarks[14].y) count++;
            if (landmarks[20].y < landmarks[18].y) count++;
            
            // Thumb approx
            if (landmarks[4].x < landmarks[3].x && landmarks[5].x > landmarks[17].x) count++; // Right
            else if (landmarks[4].x > landmarks[3].x && landmarks[5].x < landmarks[17].x) count++; // Left

            return Math.max(1, count); 
        }

        // --- Animation Loop ---
        const colorObj = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            // Update Particle Positions
            const positions = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            
            colorObj.setHSL(targetHue, 1.0, 0.6);

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;

                const tx = targetPositions[i3] * targetExpansion;
                const ty = targetPositions[i3+1] * targetExpansion;
                const tz = targetPositions[i3+2] * targetExpansion;

                positions[i3] += (tx - positions[i3]) * LERP_SPEED;
                positions[i3+1] += (ty - positions[i3+1]) * LERP_SPEED;
                positions[i3+2] += (tz - positions[i3+2]) * LERP_SPEED;

                // Vibration
                positions[i3] += (Math.random()-0.5) * 0.05;
                positions[i3+1] += (Math.random()-0.5) * 0.05;
                positions[i3+2] += (Math.random()-0.5) * 0.05;

                // Color
                cols[i3] = THREE.MathUtils.lerp(cols[i3], colorObj.r, 0.1);
                cols[i3+1] = THREE.MathUtils.lerp(cols[i3+1], colorObj.g, 0.1);
                cols[i3+2] = THREE.MathUtils.lerp(cols[i3+2], colorObj.b, 0.1);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            if(!handDetected) {
                scene.rotation.y += 0.002;
            } else {
                scene.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        setupMediaPipe();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particles - Fist Detection</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 240px; height: 180px; 
            border: 2px solid #00ffcc; 
            border-radius: 12px; 
            overflow: hidden;
            transform: scaleX(-1); /* Mirror video */
            opacity: 0.8;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: #00ffcc; pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(4px);
        }

        h1 { font-size: 1.4rem; margin: 0 0 15px 0; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0,255,204,0.5); }
        .instruction { font-size: 1rem; margin-bottom: 8px; font-weight: bold; }
        .highlight { color: #ffeb3b; text-shadow: 0 0 5px #ffeb3b; }
        .status { margin-top: 15px; font-weight: bold; color: #fff; border-top: 1px solid #333; padding-top: 10px; }
        
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-size: 1.5rem; z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        Loading AI Models...<br>
        <span style="font-size: 0.8rem; color: #fff;">Please allow camera access</span>
    </div>

    <div id="ui-layer">
        <h1>Gesture FX</h1>
        <div class="instruction highlight">‚úä Fist (Mutthi): Letters "A Y"</div>
        <div class="instruction">‚òùÔ∏è 1 Finger: Sphere</div>
        <div class="instruction">‚úåÔ∏è 2 Fingers: Heart</div>
        <div class="instruction">ü§ü 3 Fingers: Flower</div>
        <div class="instruction">üñêÔ∏è 5 Fingers: DNA Helix</div>
        <div class="status" id="status-text">Status: Waiting for camera...</div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 12000; // Increased count for denser letters
        const PARTICLE_SIZE = 0.12;
        const LERP_SPEED = 0.06;

        // --- State ---
        let currentShape = 'sphere';
        let targetHue = 0.6;
        let handDetected = false;
        
        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Init
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;
            
            positions[i*3] = x;
            positions[i*3+1] = y;
            positions[i*3+2] = z;

            targetPositions[i*3] = x;
            targetPositions[i*3+1] = y;
            targetPositions[i*3+2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9,
            map: createCircleTexture()
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Helper: Point on Line ---
        function getPointOnLine(x1, y1, x2, y2, t) {
            return {
                x: x1 + (x2 - x1) * t,
                y: y1 + (y2 - y1) * t,
                z: (Math.random() - 0.5) * 0.5 // Add a little thickness
            };
        }

        // --- Shape Generators ---
        const Shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 8;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            },
            heart: (i) => {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4;
                return { x: x * 0.5, y: y * 0.5, z: z };
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v); 
                return {
                    x: r * Math.sin(v) * Math.cos(u),
                    y: r * Math.sin(v) * Math.sin(u),
                    z: r * Math.cos(v)
                };
            },
            dna: (i) => {
                const t = (i / PARTICLE_COUNT) * 10 * Math.PI;
                const radius = 3;
                const height = 20;
                const y = (i / PARTICLE_COUNT) * height - height/2;
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                return {
                    x: radius * Math.cos(t + offset),
                    y: y,
                    z: radius * Math.sin(t + offset)
                };
            },
            // NEW: The "AY" Letter Generator
            ay: (i) => {
                const halfCount = PARTICLE_COUNT / 2;
                
                // --- Letter A (Left Side) ---
                if (i < halfCount) {
                    const t = i / halfCount; // 0 to 1 progress for A
                    const offsetX = -6; // Move A to left
                    
                    // A is 3 parts: Left Leg (40%), Right Leg (40%), Bar (20%)
                    if (t < 0.4) {
                        // Left Leg: Bottom Left (-3, -5) to Top (0, 5)
                        const localT = t / 0.4;
                        const p = getPointOnLine(-3, -5, 0, 5, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    } else if (t < 0.8) {
                        // Right Leg: Top (0, 5) to Bottom Right (3, -5)
                        const localT = (t - 0.4) / 0.4;
                        const p = getPointOnLine(0, 5, 3, -5, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    } else {
                        // Bar: Left (-1.5, -1) to Right (1.5, -1)
                        const localT = (t - 0.8) / 0.2;
                        const p = getPointOnLine(-1.5, -1, 1.5, -1, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    }
                } 
                // --- Letter Y (Right Side) ---
                else {
                    const t = (i - halfCount) / halfCount; // 0 to 1 progress for Y
                    const offsetX = 6; // Move Y to right

                    // Y is 3 parts: Left Arm (33%), Right Arm (33%), Stem (34%)
                    if (t < 0.33) {
                        // Left Arm: Top Left (-3, 5) to Center (0, 0)
                        const localT = t / 0.33;
                        const p = getPointOnLine(-3, 5, 0, 0, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    } else if (t < 0.66) {
                        // Right Arm: Top Right (3, 5) to Center (0, 0)
                        const localT = (t - 0.33) / 0.33;
                        const p = getPointOnLine(3, 5, 0, 0, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    } else {
                        // Stem: Center (0, 0) to Bottom (0, -5)
                        const localT = (t - 0.66) / 0.34;
                        const p = getPointOnLine(0, 0, 0, -5, localT);
                        return { x: p.x + offsetX, y: p.y, z: p.z };
                    }
                }
            }
        };

        function updateShapeTargets(shapeName) {
            const generator = Shapes[shapeName];
            if(!generator) return;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const pos = generator(i);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
        }

        updateShapeTargets('sphere');

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.Texture(canvas);
        }

        // --- MediaPipe Setup ---
        let handLandmarker = undefined;
        let webcam = document.getElementById('webcam');
        let lastVideoTime = -1;

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').innerText = "Status: AI Ready. Enable Camera.";
            startCamera();
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                webcam.srcObject = stream;
                webcam.addEventListener('loadeddata', predictWebcam);
                document.getElementById('status-text').innerText = "Status: Tracking Active";
            });
        }

        async function predictWebcam() {
            if (lastVideoTime !== webcam.currentTime) {
                lastVideoTime = webcam.currentTime;
                const startTimeMs = performance.now();
                if (handLandmarker) {
                    const result = await handLandmarker.detectForVideo(webcam, startTimeMs);
                    processHandData(result);
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        // --- Interaction Logic ---
        function processHandData(result) {
            const statusText = document.getElementById('status-text');

            if (result.landmarks && result.landmarks.length > 0) {
                handDetected = true;
                const landmarks = result.landmarks[0];
                
                // Color Control (Wrist X Position)
                targetHue = landmarks[0].x;

                // Finger Counting
                const count = countFingers(landmarks);
                
                let newShape = currentShape;

                // --- SHAPE SWITCHING LOGIC ---
                if(count === 0) newShape = 'ay'; // MUTTHI / FIST
                else if(count === 1) newShape = 'sphere';
                else if(count === 2) newShape = 'heart';
                else if(count === 3) newShape = 'flower';
                else if(count === 4) newShape = 'sphere'; // Fallback
                else if(count === 5) newShape = 'dna';

                if(newShape !== currentShape) {
                    currentShape = newShape;
                    updateShapeTargets(currentShape);
                    
                    let shapeNameDisplay = currentShape.toUpperCase();
                    if(currentShape === 'ay') shapeNameDisplay = "LETTERS A & Y";

                    statusText.innerText = `Shape: ${shapeNameDisplay} | Fingers: ${count}`;
                    
                    // Add a snap effect on shape change
                    if(currentShape === 'ay') {
                        controls.autoRotateSpeed = 0; // Stop rotation to read letters
                        scene.rotation.y = 0; // Reset rotation
                    } else {
                        controls.autoRotateSpeed = 1.0;
                    }
                }

            } else {
                handDetected = false;
            }
        }

        function countFingers(landmarks) {
            let count = 0;
            // Tips: 8(Index), 12(Middle), 16(Ring), 20(Pinky)
            // PIP Joints: 6, 10, 14, 18
            // If Tip Y < PIP Y (remember Y is inverted), finger is extended
            
            if (landmarks[8].y < landmarks[6].y) count++;
            if (landmarks[12].y < landmarks[10].y) count++;
            if (landmarks[16].y < landmarks[14].y) count++;
            if (landmarks[20].y < landmarks[18].y) count++;
            
            // Thumb (Tip 4, IP 3) - Check X distance relative to Pinky
            // If right hand: Thumb tip to left of IP is open
            // Simplified check: Is thumb extended away from palm?
            // We'll use a simple distance check from wrist for thumb
            const thumbDist = Math.sqrt(
                Math.pow(landmarks[4].x - landmarks[0].x, 2) + 
                Math.pow(landmarks[4].y - landmarks[0].y, 2)
            );
            // If thumb is far from wrist, count it
            if(thumbDist > 0.3) count++; // Approximate threshold

            return count; // Returns 0 for fist, up to 5
        }

        // --- Animation Loop ---
        const colorObj = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            // Update Particle Positions
            const pos = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            
            // Logic: If showing A Y, make it Gold, otherwise Dynamic Hue
            if(currentShape === 'ay') {
                colorObj.setHex(0xFFD700); // Gold
            } else {
                colorObj.setHSL(targetHue, 1.0, 0.6);
            }

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;

                // Move to target
                const tx = targetPositions[i3];
                const ty = targetPositions[i3+1];
                const tz = targetPositions[i3+2];

                pos[i3] += (tx - pos[i3]) * LERP_SPEED;
                pos[i3+1] += (ty - pos[i3+1]) * LERP_SPEED;
                pos[i3+2] += (tz - pos[i3+2]) * LERP_SPEED;

                // "Alive" Vibration
                const vibration = 0.03;
                pos[i3] += (Math.random()-0.5) * vibration;
                pos[i3+1] += (Math.random()-0.5) * vibration;
                pos[i3+2] += (Math.random()-0.5) * vibration;

                // Color Lerp
                cols[i3] = THREE.MathUtils.lerp(cols[i3], colorObj.r, 0.05);
                cols[i3+1] = THREE.MathUtils.lerp(cols[i3+1], colorObj.g, 0.05);
                cols[i3+2] = THREE.MathUtils.lerp(cols[i3+2], colorObj.b, 0.05);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            if(!handDetected && currentShape !== 'ay') {
                scene.rotation.y += 0.002;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        // Ensure texture is loaded on material
        material.map.needsUpdate = true;
        setupMediaPipe();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

