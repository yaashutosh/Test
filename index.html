<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Hand & Audio Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none;
        }
        #video-container {
            position: absolute; bottom: 10px; left: 10px;
            width: 160px; height: 120px; border: 2px solid #00ffcc;
            transform: scaleX(-1); /* Mirror video */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; font-size: 24px; background: #00ffcc; border: none;
            cursor: pointer; z-index: 10;
        }
    </style>
</head>
<body>

<div id="info">
    <h2>Particle Conductor</h2>
    <p>üñê <b>Move Hand:</b> Attract particles</p>
    <p>ü§è <b>Pinch (Thumb+Index):</b> Change Color & Sound Pitch</p>
    <p>‚úä <b>Fist/Close:</b> Switch Shape (Sphere/Cube)</p>
</div>

<div id="video-container">
    <video id="input-video" autoplay playsinline muted></video>
</div>

<button id="start-btn">Click to Start Experience</button>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
        "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- CONFIGURATION ---
const PARTICLE_COUNT = 15000;
const HAND_Z_DEPTH = 10; // How "deep" the hand feels in 3D

// --- STATE MANAGEMENT ---
const state = {
    handDetected: false,
    handPosition: new THREE.Vector3(0, 0, 0),
    pinchDistance: 1, // 0 = closed, 1 = open
    shapeIndex: 0, // 0 = sphere, 1 = cube
    audioStarted: false
};

// --- AUDIO SYSTEM (Web Audio API) ---
let audioCtx, oscillator, gainNode, analyser, dataArray;

function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    oscillator = audioCtx.createOscillator();
    oscillator.type = 'sine';
    
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0; // Start silent

    oscillator.connect(gainNode);
    gainNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    
    oscillator.start();
    state.audioStarted = true;
}

function updateAudio(pinch, yPos) {
    if (!state.audioStarted) return;

    // Map Pinch to Volume (Closed = Loud, Open = Quiet)
    // Inverting pinch so close = 1 (loud)
    const targetVol = Math.max(0, 1 - pinch); 
    gainNode.gain.setTargetAtTime(targetVol * 0.3, audioCtx.currentTime, 0.1);

    // Map Y Position to Frequency (Theremin style)
    const minFreq = 100;
    const maxFreq = 800;
    // Normalized Y (-10 to 10 approx) -> 0 to 1
    const normY = (yPos + 5) / 10; 
    const targetFreq = THREE.MathUtils.clamp(normY * maxFreq + minFreq, minFreq, maxFreq);
    oscillator.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
}

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// --- PARTICLE SYSTEM ---
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // For shape morphing
const colors = new Float32Array(PARTICLE_COUNT * 3);
const randomness = new Float32Array(PARTICLE_COUNT * 3);

// Initialize Particles (Sphere Shape)
const color1 = new THREE.Color(0x00ffcc);
const color2 = new THREE.Color(0xff00cc);

for (let i = 0; i < PARTICLE_COUNT; i++) {
    // Random Point in Sphere
    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
    const r = 10;

    const x = r * Math.cos(theta) * Math.sin(phi);
    const y = r * Math.sin(theta) * Math.sin(phi);
    const z = r * Math.cos(phi);

    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;

    // Pre-calculate target (start as same)
    targetPositions[i * 3] = x;
    targetPositions[i * 3 + 1] = y;
    targetPositions[i * 3 + 2] = z;

    // Random noise
    randomness[i * 3] = (Math.random() - 0.5);
    randomness[i * 3 + 1] = (Math.random() - 0.5);
    randomness[i * 3 + 2] = (Math.random() - 0.5);

    // Initial Color
    color1.toArray(colors, i * 3);
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

// Shader Material for Performance & Effects
const material = new THREE.ShaderMaterial({
    uniforms: {
        uTime: { value: 0 },
        uSize: { value: 4.0 },
        uHandPos: { value: new THREE.Vector3(0, 0, 0) },
        uPinch: { value: 0.0 },
        uAudioLow: { value: 0.0 }, // Bass
        uAudioHigh: { value: 0.0 } // Treble
    },
    vertexShader: `
        uniform float uTime;
        uniform float uSize;
        uniform vec3 uHandPos;
        uniform float uPinch;
        uniform float uAudioLow;
        
        attribute vec3 color;
        varying vec3 vColor;

        void main() {
            vColor = color;
            vec3 pos = position;

            // Audio Vibration (High freq shake)
            pos += normal * uAudioLow * 2.0;

            // Hand Attraction/Repulsion
            float dist = distance(pos, uHandPos);
            float attractionForce = max(0.0, 15.0 - dist);
            
            // If pinching, attract closer. If not, slight repel.
            vec3 dir = normalize(uHandPos - pos);
            pos += dir * attractionForce * (uPinch > 0.5 ? 0.5 : -0.2);

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = uSize * (100.0 / -mvPosition.z) * (1.0 + uAudioLow);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        varying vec3 vColor;
        uniform float uPinch;

        void main() {
            // Circular particle
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;

            // Mix color based on pinch
            vec3 finalColor = mix(vColor, vec3(1.0, 0.5, 0.2), 1.0 - uPinch);
            
            // Soft edge glow
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.5);

            gl_FragColor = vec4(finalColor, glow);
        }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// --- SHAPE TEMPLATES ---
function generateShape(type) {
    const arr = [];
    if (type === 0) { // Sphere
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            const r = 10;
            arr.push(r * Math.cos(theta) * Math.sin(phi), r * Math.sin(theta) * Math.sin(phi), r * Math.cos(phi));
        }
    } else if (type === 1) { // Cube
        const side = 15;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            arr.push((Math.random() - 0.5) * side, (Math.random() - 0.5) * side, (Math.random() - 0.5) * side);
        }
    }
    return arr;
}
const shapes = [generateShape(0), generateShape(1)];

// --- MEDIAPIPE HANDS SETUP ---
async function setupCamera() {
    const video = document.getElementById('input-video');
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
    video.srcObject = stream;
    return new Promise(resolve => video.onloadedmetadata = resolve);
}

// Load MediaPipe dynamically
import { Hands } from '@mediapipe/hands';

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(results => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        state.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];

        // 1. Get Palm Position (Index 9 is a stable central point)
        const x = (0.5 - landmarks[9].x) * 30; // Scale to world
        const y = (0.5 - landmarks[9].y) * 20;
        const z = -landmarks[9].z * 30; // Estimate depth
        
        // Smooth lerp
        state.handPosition.lerp(new THREE.Vector3(x, y, z), 0.1);

        // 2. Calculate Pinch (Distance between Thumb Tip 4 and Index Tip 8)
        const thumb = new THREE.Vector3(landmarks[4].x, landmarks[4].y, landmarks[4].z);
        const index = new THREE.Vector3(landmarks[8].x, landmarks[8].y, landmarks[8].z);
        const dist = thumb.distanceTo(index);
        
        // Normalize pinch: 0.05 is close, 0.15 is far
        state.pinchDistance = THREE.MathUtils.clamp((dist - 0.02) * 8, 0, 1);

        // 3. Shape Switch Trigger (Fist Check: all fingertips close to palm)
        // Simple Logic: if pinch is very close for 20 frames, switch
        if (state.pinchDistance < 0.1) {
            // Very basic debounce handled by slow morphing in loop
            state.shapeIndex = 1; // Cube
        } else {
            state.shapeIndex = 0; // Sphere
        }

    } else {
        state.handDetected = false;
        // Reset pinch to open if lost
        state.pinchDistance = THREE.MathUtils.lerp(state.pinchDistance, 1.0, 0.1);
    }
});

// Process video frames
const videoElement = document.getElementById('input-video');
async function cameraLoop() {
    if (state.audioStarted) { // Only process if started
        await hands.send({image: videoElement});
    }
    requestAnimationFrame(cameraLoop);
}

// --- MAIN LOOP ---
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const time = clock.getElapsedTime();
    
    // 1. Audio Analysis
    let audioLow = 0;
    if (state.audioStarted) {
        analyser.getByteFrequencyData(dataArray);
        // Average lower frequencies for bass/beat
        let sum = 0;
        for(let i = 0; i < 20; i++) sum += dataArray[i];
        audioLow = sum / 20 / 255.0; // 0.0 to 1.0
        
        // Update sound synthesis
        updateAudio(state.pinchDistance, state.handPosition.y);
    }

    // 2. Physics & Morphing
    const positionsAttribute = geometry.attributes.position;
    const currentPositions = positionsAttribute.array;
    const targetShape = shapes[state.shapeIndex];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // Morphing: Move current position toward target shape
        // Add "Sound Wave" distortion to target
        const tx = targetShape[i3];
        const ty = targetShape[i3+1];
        const tz = targetShape[i3+2];
        
        // Lerp factor
        currentPositions[i3] += (tx - currentPositions[i3]) * 0.05;
        currentPositions[i3+1] += (ty - currentPositions[i3+1]) * 0.05;
        currentPositions[i3+2] += (tz - currentPositions[i3+2]) * 0.05;
    }
    positionsAttribute.needsUpdate = true;

    // 3. Update Uniforms
    material.uniforms.uTime.value = time;
    material.uniforms.uHandPos.value.copy(state.handPosition);
    material.uniforms.uPinch.value = state.pinchDistance;
    material.uniforms.uAudioLow.value = audioLow;

    renderer.render(scene, camera);
}

// Start Button Listener
document.getElementById('start-btn').addEventListener('click', async () => {
    document.getElementById('start-btn').style.display = 'none';
    initAudio();
    await setupCamera();
    cameraLoop();
    animate();
});

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
